buildscript {
    repositories {
      	mavenLocal()
        jcenter()
        mavenCentral()
        maven { url = "https://files.minecraftforge.net/maven" }
        maven {
            name = 'gradle'
            url 'https://plugins.gradle.org/m2/'
        }
        maven {
            name = 'sonatype'
            url = 'https://oss.sonatype.org/content/groups/public'
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
		classpath 'com.selesse:gradle-git-changelog:0.2.+'
    }
}

plugins {
    id 'com.matthewprenger.cursegradle' version '1.4.0'
    id "com.wynprice.cursemaven" version "2.1.1"
	id 'net.minecrell.licenser' version '0.4.1'
    id "com.jfrog.bintray" version "1.8.1"
    id 'net.ltgt.apt' version '0.10' // for lombok
    id 'maven-publish'
    id 'java'
}

apply plugin: 'com.selesse.git.changelog'

defaultTasks 'licenseFormat'

//apply from: "https://raw.githubusercontent.com/ROMVoid95/Common-Gradle/master/build.gradle"

static def getCurrentYear() {
    def date = new Date()
    return date.format('yyyy')
}

license {
    ext {
        name = "Interstellar: Exoplanets"
        organization = "ROMVoid95"
        email = "rom.readonlydev@gmail.com"
        year = getCurrentYear()
    }

    header = file('HEADER')
    include '**/*.java'
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
    options.compilerArgs = [
            '-Xlint:deprecation' // deprecation, rawtypes, cast, unchecked, all
    ]
}

javadoc {
    failOnError = false
}

apply plugin: 'net.minecraftforge.gradle.forge'

eclipse.project {
    buildCommand 'org.eclipse.buildship.core.gradleprojectbuilder'
    natures 'org.eclipse.buildship.core.gradleprojectnature'
}

apply from: 'gradle/secret.gradle'

def versionInfo = getModVersion()
System.out.println(versionInfo)
version = "${versionInfo['version']}"
def build_num = getBuildNumber()

group = "${group}"
archivesBaseName = "${name}"

sourceCompatibility = targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.
compileJava {
    sourceCompatibility = targetCompatibility = '1.8'
}

String GCBuild = "261"
String GCVersion = "1.12.2-4.0.2.${GCBuild}"

repositories {
    ivy {
        url "https://ci.micdoodle8.com/job/"
        layout 'pattern', {
            artifact "[organization]/${GCBuild}/artifact/Forge/build/libs/[module]-[revision].jar"
        }
        metadataSources { 
            artifact()
        }
    }
	maven {
		name = 'curseforge'
		url = 'https://minecraft.curseforge.com/api/maven/'
	}    
	maven {
	    name 'MJRLegends'
	    url = "https://maven.mjrlegends.com/"
    }
    maven {
        name 'DVS1 Maven FS'
        url 'http://dvs1.progwml6.com/files/maven'
    }
    jcenter()
    mavenCentral()
}

dependencies {

    // lombok
    if (project.hasProperty('lombok_version')) {
        compile "org.projectlombok:lombok:${project.lombok_version}"
        apt "org.projectlombok:lombok:${project.lombok_version}"
    }
    
    compile "curse.maven:plprogapi-0.4.4:2941452"
    compile "curse.maven:asmodeusdev-0.0.65:2953213"
	//compile files ('/acore-0.16.jar')
	
    compile "mezz.jei:jei_${mc_version}:${jei_version}:api"
    runtime "mezz.jei:jei_${mc_version}:${jei_version}"
    	
    compile "Galacticraft-1.12-dev:GalacticraftCore-Dev:${GCVersion}"
    deobfProvided  "Galacticraft-1.12-dev:Galacticraft-API:${GCVersion}"
    compile "Galacticraft-1.12-dev:Galacticraft-Planets-Dev:${GCVersion}"
    compile "Galacticraft-1.12-dev:MicdoodleCore-Dev:${GCVersion}"
    
    compile 'org.apache.commons:commons-math3:3.6.1'
    
    // Use JUnit test framework
    testImplementation 'junit:junit:4.13'
    

}


apply from: 'gradle/curseforge.gradle'

minecraft {
    version = project.forge_mc_version + '-' + project.forge_version
    runDir = 'run'
    mappings = project.mcp_mappings_version

	replace "@BUILD@", build_num
    replace "@VERSION@", "${versionInfo['version']}"
    replaceIn "Exoinfo.java"

    if (project.hasProperty('coreplugin')) {
        clientJvmArgs += '-Dfml.coreMods.load=' + project.coreplugin
        serverJvmArgs += '-Dfml.coreMods.load=' + project.coreplugin
    }

    if (project.hasProperty('mc_username')) {
        clientRunArgs += ['--username', project.mc_username]
        if (project.hasProperty('mc_password')) {
            clientRunArgs += ['--password', project.mc_password]
        }
    }
    if (project.hasProperty('mc_uuid')) {
        clientRunArgs += ['--uuid', project.mc_uuid]
    }

    // disable server gui
    serverRunArgs += 'nogui'

    // skip the screen to confirm that you want to load a world with missing registry entries
    serverJvmArgs += '-Dfml.doNotBackup=true'
    clientJvmArgs += '-Dfml.doNotBackup=true'

    // skip having to confirm on server
    serverJvmArgs += '-Dfml.queryResult=confirm'

    //skip jansi warnings in the log
    serverJvmArgs += '-Dlog4j.skipJansi=true'
    clientJvmArgs += '-Dlog4j.skipJansi=true'

    if (project.hasProperty('client_args')) {
        clientJvmArgs += project.client_args
    }
    if (project.hasProperty('server_args')) {
        serverJvmArgs += project.server_args
    }
}


processResources {
    inputs.property 'version', "${versionInfo['version']}"
    inputs.property 'mcversion', project.minecraft.version

    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
    }

    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }

    rename '(exoplanets_at.cfg)', 'META-INF/$1'
}

import java.util.regex.Matcher

jar {
	manifest {
		mainAttributes(
		  'Timestamp': System.currentTimeMillis(),
		  'Specification-Title': 'exoplanets',
		  'Specification-Vendor': 'romvoid95',
		  'Specification-Version': '1',
		  'Implementation-Title': project.archivesBaseName,
		  'Implementation-Version': project.version,
		  'Implementation-Vendor' :'ROMVoid95',
		  'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
		  'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
		  'Built-On': "${project.forge_mc_version}-${project.forge_version}"
		)
		if (project.hasProperty('core_plugin')) {
		  attributes 'FMLCorePluginContainsFMLMod': 'true'
		  attributes 'FMLCorePlugin': project.core_plugin
		}
		if (project.hasProperty('mod_at_file')) {
		  attributes 'FMLAT': project.mod_at_file
		}
		if (project.hasProperty('mod_contained_deps')) {
			attributes 'ContainedDeps': project.mod_contained_deps
		}
	  }
}

task apiJar(type: Jar) {
    onlyIf {
        getBooleanProperty('create_api_jar')
    }
    from(sourceSets.main.output) {
        include "net/rom/api/**"
    }
	from(sourceSets.main.java) {
        include "net/rom/api/**"
    }

    classifier = 'api'
    from apiClasses
    // from sourceSets.api.output
    manifest.mainAttributes(
            'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}:api",
            'Timestamp': System.currentTimeMillis(),
            'Implementation-Title': project.name + '-api',
            'Implementation-Version': project.version,
            'Built-On': "${project.mc_version}-${project.forge_version}",
            'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})"
    )
}

task deobfJar(type: Jar) {
    onlyIf {
        getBooleanProperty('create_deobf_jar')
    }

    classifier = 'dev'
    from sourceSets.main.output
    manifest {
        mainAttributes(
                'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}:deobf",
                'Timestamp': System.currentTimeMillis(),
                'Implementation-Title': project.name + '-deobf',
                'Implementation-Version': project.version,
                'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
                'Built-On': "${project.mc_version}-${project.forge_version}"
        )
        if (project.hasProperty('at_file')) {
            attributes 'FMLAT': project.at_file
        }
        if (project.hasProperty('core_plugin')) {
            attributes 'FMLCorePlugin': project.core_plugin
        }
    }
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    onlyIf {
        getBooleanProperty('create_javadoc_jar')
    }

    classifier = 'javadoc'
    from javadoc.getDestinationDir()
    manifest.mainAttributes(
            'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}:javadoc",
            'Timestamp': System.currentTimeMillis(),
            'Implementation-Title': project.name + '-javadoc',
            'Implementation-Version': project.version,
            'Built-On-Java': "${System.getProperty('java.vm.version')} + (${System.getProperty('java.vm.vendor')})",
            'Built-On': "${project.mc_version}-${project.forge_version}"
    )
}

task signJar(type: SignJar, dependsOn: reobfJar) {
    onlyIf {
        getBooleanProperty('do_sign_jar') &&
                project.hasProperty('keyStore')
    }

    inputFile = jar.archivePath
    outputFile = jar.archivePath

    keyStore = secret.keyStore
    alias = secret.keyStoreAlias
    storePass = secret.keyStorePass
    keyPass = secret.keyStoreKeyPass
}

task signApiJar(type: SignJar) {
    onlyIf {
        getBooleanProperty('create_api_jar') &&
                getBooleanProperty('do_sign_jar') &&
                project.hasProperty('keyStore')
    }

    keyStore = secret.keyStore
    alias = secret.keyStoreAlias
    storePass = secret.keyStorePass
    keyPass = secret.keyStoreKeyPass

    inputFile = apiJar.archivePath
    outputFile = apiJar.archivePath
}

task signDeobfJar(type: SignJar) {
    onlyIf {
        getBooleanProperty('create_deobf_jar') &&
                getBooleanProperty('do_sign_jar') &&
                project.hasProperty('keyStore')
    }

    keyStore = secret.keyStore
    alias = secret.keyStoreAlias
    storePass = secret.keyStorePass
    keyPass = secret.keyStoreKeyPass

    inputFile = deobfJar.archivePath
    outputFile = deobfJar.archivePath
}

task signSourceJar(type: SignJar) {
    onlyIf {
        getBooleanProperty('create_source_jar') &&
                getBooleanProperty('do_sign_jar') &&
                project.hasProperty('keyStore')
    }

    keyStore = secret.keyStore
    alias = secret.keyStoreAlias
    storePass = secret.keyStorePass
    keyPass = secret.keyStoreKeyPass

    inputFile = sourceJar.archivePath
    outputFile = sourceJar.archivePath
}

task signJavadocJar(type: SignJar) {
    onlyIf {
        getBooleanProperty('create_javadoc_jar') &&
                getBooleanProperty('do_sign_jar') &&
                project.hasProperty('keyStore')
    }

    keyStore = secret.keyStore
    alias = secret.keyStoreAlias
    storePass = secret.keyStorePass
    keyPass = secret.keyStoreKeyPass

    inputFile = javadocJar.archivePath
    outputFile = javadocJar.archivePath
}

if (getBooleanProperty('do_sign_jar')) {
    build.dependsOn signJar
    build.dependsOn signApiJar
    build.dependsOn signDeobfJar
    build.dependsOn signSourceJar
    build.dependsOn signJavadocJar
}

tasks.publish.dependsOn build
tasks.curseforge.dependsOn publish

artifacts {
    if (getBooleanProperty('create_api_jar')) {
        archives apiJar
    }
    if (getBooleanProperty('create_deobf_jar')) {
        archives deobfJar
    }
    if (getBooleanProperty('create_source_jar')) {
        archives sourceJar
    }
    if (getBooleanProperty('create_javadoc_jar')) {
        archives javadocJar
    }
}

// Version stuff

boolean getBooleanProperty(final String property) {
    if (project.hasProperty(property)) {
        return ((String) project.findProperty(property)).toBoolean()
    } else {
        return false
    }
}

def getModVersion() {
    try {
        return getGitVersion()
    } catch (Exception ex) {
        System.out.println("Git version failed, falling back to old method")
        return getVersion('VERSION', getModFile())
    }
}

def getGitVersion() {
    // Call git command
    def outStream = new ByteArrayOutputStream()
    def result = exec {
        executable = 'git'
        args = [ 'describe', '--tag' ]
        standardOutput = outStream
    }

    def fullVersion = outStream.toString().trim()
    def matcher = fullVersion =~ /(\d+).(\d+).(\d+)-(.*)/

    def maj = matcher[0][1]
    def min = matcher[0][2]
    def rev = matcher[0][3]
    def bn = getBuildNumber()

    return makeVersionMap(maj, min, rev, bn, matcher[0][4])
}

static def makeVersionMap(maj, min, rev, bn, githash) {
    def out = [:]
    out['build.major.number'] = maj.toString()
    out['build.minor.number'] = min.toString()
    out['build.revision.number'] = rev.toString()
    out['build.githash'] = githash
    out['build.number'] = bn.toString()
    out['version_short'] = "${maj}.${min}.${rev}".toString()
    out['version'] = "${maj}.${min}.${rev}-[${bn}]".toString()
    return out
}

// Modified old version getter
def getVersion(String type, String mod_file) {
    String maj = '0'
    String min = '0'
    String rev = '0'
    String bn = getBuildNumber()

    File file = file(mod_file)
    def prefix = ~/^(?:public|protected|private) static final String $type = ".*$/
    file.eachLine { String s ->
        s = s.trim()
        if (s ==~ prefix || prefix.matcher(s).matches()) {
            String[] bits = s.split("=")
            String interesting = bits[1].trim()
            interesting = interesting.substring(1, interesting.length() - 2)
            String[] pts = interesting.trim().split("\\.")

            maj = pts[0] ?: '0'
            min = pts[1] ?: '0'
            rev = pts[2] ?: '0'
        }
    }

    return makeVersionMap(maj, min, rev, bn, 'unknown')
}

// Used by old getVersion
String getModFile() {
    String path = ''
    FileTree tree = fileTree(dir: 'src' )
    tree.include '**/*.java'
    tree.visit { element ->
        if (element.file.isFile()) {
            element.file.eachLine { String s ->
                s = s.trim()
                if (s.startsWith('@Mod(')) {
                    path = "src/$element.relativePath"
                }
            }
        }
    }
    return path
}

// Build number tracking

String getBuildNumber() {
    def versionFile = file('version.properties')
    if (versionFile.canRead()) {
        Properties versionProps = new Properties()
        versionProps.load(new FileInputStream(versionFile))
        return versionProps['build_num'].toString()
    }
    return "1"
}

task incrementBuild {
    doFirst {
        def versionFile = file('version.properties')
        if (versionFile.canRead()) {
            Properties versionProps = new Properties()
            versionProps.load(new FileInputStream(versionFile))
            def num = versionProps['build_num'].toInteger() + 1
            println("incrementing BuildNumber to: " + num)
            versionProps['build_num'] = num.toString()
            versionProps.store(versionFile.newWriter(), null)
        } else {
            println("version.properties file not found! Ignoring.")
        }
    }
}

curseforge {
	if (project.hasProperty('cf_project_id')) {
		apiKey = secret.curseforgeAPIKey
		project {
			id = project.cf_project_id
			if (project.hasProperty('cf_changelog_filename')) {
				changelog = file(project.cf_changelog_filename)
			} else {
				changelog = ''
			}
			if (project.hasProperty('cf_changelog_type')) {
				changelogType = project.cf_changelog_type
			}
			if ((project.hasProperty('cf_release_type')) && ((project.cf_release_type == 'alpha') || (project.cf_release_type == 'beta') || (project.cf_release_type == 'release'))) {
				releaseType = project.cf_release_type
			} else {
				releaseType = 'alpha'
			}
			if (project.hasProperty('cf_versions')) {
				final def versions = "${project.cf_versions}".split(', ')
				versions.each {
					addGameVersion "${it}"
				}
			}
			mainArtifact(jar) {
				if (getBooleanProperty('cf_use_custom_display_name')) {
					displayName = "${project.name} ${project.display_version}"
				}
				if (project.hasProperty('cf_requirements') || project.hasProperty('cf_optionals') || project.hasProperty('cf_embeddeds') || project.hasProperty('cf_tools') || project.hasProperty('cf_incompatibles') || project.hasProperty('cf_includes')) {
					relations {
						if (project.hasProperty('cf_requirements')) {
							final def requirements = "${project.cf_requirements}".split(', ')
							requirements.each {
								requiredDependency "${it}"
							}
						}
						if (project.hasProperty('cf_optionals')) {
							final def optionals = "${project.cf_optionals}".split(', ')
							optionals.each {
								optionalDependency "${it}"
							}
						}
						if (project.hasProperty('cf_embeddeds')) {
							final def embeddeds = "${project.cf_embeddeds}".split(', ')
							embeddeds.each {
								embeddedLibrary "${it}"
							}
						}
						if (project.hasProperty('cf_tools')) {
							final def tools = "${project.cf_tools}".split(', ')
							tools.each {
								tool "${it}"
							}
						}
						if (project.hasProperty('cf_incompatibles')) {
							final def incompatibles = "${project.cf_incompatibles}".split(', ')
							incompatibles.each {
								incompatible "${it}"
							}
						}
						if (project.hasProperty('cf_includes')) {
							final def includes = "${project.cf_includes}".split(', ')
							includes.each {
								include "${it}"
							}
						}
					}
				}
			}
			if (getBooleanProperty('create_api_jar')) {
				addArtifact(apiJar) {
					if (getBooleanProperty('cf_use_custom_display_name')) {
						displayName = "${project.name} ${project.display_version} API"
					}
				}
			}
			if (getBooleanProperty('create_source_jar')) {
				addArtifact(sourceJar) {
					if (getBooleanProperty('cf_use_custom_display_name')) {
						displayName = "${project.name} ${project.display_version} Sources"
					}
				}
			}
			if (getBooleanProperty('create_deobf_jar')) {
				addArtifact(deobfJar) {
					if (getBooleanProperty('cf_use_custom_display_name')) {
						displayName = "${project.name} ${project.display_version} Development"
					}
				}
			}
			if (getBooleanProperty('create_javadoc_jar')) {
				addArtifact(javadocJar) {
					if (getBooleanProperty('cf_use_custom_display_name')) {
						displayName = "${project.name} ${project.display_version} Javadoc"
					}
				}
			}
		}
	}
}


build.finalizedBy incrementBuild // only increment on successful builds
